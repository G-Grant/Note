(window.webpackJsonp=window.webpackJsonp||[]).push([[34],{409:function(n,e,o){"use strict";o.r(e);var t=o(25),r=Object(t.a)({},(function(){var n=this,e=n.$createElement,o=n._self._c||e;return o("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[o("h1",{attrs:{id:"symbol"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#symbol","aria-hidden":"true"}},[n._v("#")]),n._v(" Symbol")]),n._v(" "),o("p",[n._v("原始数据类型，表示独一无二的值，现共七种数据类型。"),o("code",[n._v("undefined")]),n._v("、"),o("code",[n._v("null")]),n._v("、"),o("code",[n._v("布尔值")]),n._v("、"),o("code",[n._v("字符串")]),n._v("、"),o("code",[n._v("Number")]),n._v("、"),o("code",[n._v("Symbol")]),n._v(" 和 "),o("code",[n._v("Object")]),n._v("。")]),n._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",[o("code",[n._v("- `Symbol` 函数的参数只是对当前 `Symbol` 值得描述，因此相同参数的 `Symbol` 函数返回值不相等。\n\n    ```js\n    Symbol() === Symbol() // false\n    Symbol('foo') === Symbol('foo) // false\n    ```\n\n- `Symbol` 值不能与其他类型值进行计算\n- `Symbol` 可以显示转换为字符串\n- `Symbol` 可以转换为布尔值，但是不能转换为数值\n- `Symbol` 如果需要读取描述，可以通过 `Symbol('foo').description` 读取 `foo`\n- `Symbol` 作为属性名，只能通过 `Object.getOwnPropertySymbols` 方法获取指定对象的所有 `Symbol` 属性名，返回一个数组，成员为当前对象的所有用作属性名的 `Symbol` 值\n- 如果希望使用同一个 `Symbol` 值，可以通过 `Symbol.for` 实现\n- 对象的 `Symbol.hasInstance` 属性，指向一个内部方法。当其他对象使用 `instanceof` 运算符，判断是否为该对象的实例时，会调用这个方法。\n- 对象的 `Symbol.isConcatSpreadable` 属性等于一个布尔值，表示该对象用于 `Array.prototype.concat()` 时，是否可以展开。`Symbol.isConcatSpreadable`  默认等于 `undefined`，也可以展开数组。\n\n```js\nlet arr2 = ['c', 'd'];\narr2[Symbol.isConcatSpreadable] = false;\n['a', 'b'].concat(arr2, 'e') // ['a', 'b', ['c','d'], 'e']\n ```\n\n- 对象的Symbol.species属性，指向一个构造函数。创建衍生对象时，会使用该属性。`b` 和 `c` 是 `a` 的衍生对象。\n\n    ```js\n    class MyArray extends Array {\n    }\n\n    const a = new MyArray(1, 2, 3);\n    const b = a.map(x => x);\n    const c = a.filter(x => x > 1);\n\n    b instanceof MyArray // true\n    c instanceof MyArray // true\n    ```\n\n- 对象的Symbol.replace属性，指向一个方法，当该对象被String.prototype.replace方法调用时，会返回该方法的返回值。\n\n    ```js\n    String.prototype.replace(searchValue, replaceValue)\n    // 等同于\n    searchValue[Symbol.replace](this, replaceValue)\n    ```\n\n- 对象的 `Symbol.search` 属性，指向一个方法，当该对象被 `String.prototype.search` 方法调用时，会返回该方法的返回值。\n- 对象的 `Symbol.split` 属性，指向一个方法，当该对象被 `String.prototype.split` 方法调用时，会返回该方法的返回值。\n- 对象的 `Symbol.iterator` 属性，指向该对象的默认遍历器方法。\n- 对象的 `Symbol.toPrimitive` 属性，指向一个方法。该对象被转为原始类型的值时，会调用这个方法，返回该对象对应的原始类型值。`Symbol.toPrimitive` 被调用时，会接受一个字符串参数，表示当前运算的模式，一共有三种模式。\n\n    - Number：该场合需要转成数值\n    - String：该场合需要转成字符串\n    - Default：该场合可以转成数值，也可以转成字符串\n\n    ```js\n    let obj = {\n    [Symbol.toPrimitive](hint) {\n        switch (hint) {\n        case 'number':\n            return 123;\n        case 'string':\n            return 'str';\n        case 'default':\n            return 'default';\n        default:\n            throw new Error();\n        }\n    }\n    };\n\n    2 * obj // 246\n    3 + obj // '3default'\n    obj == 'default' // true\n    String(obj) // 'str'\n    ```\n")])])]),n._v(" "),o("comment-comment")],1)}),[],!1,null,null,null);e.default=r.exports}}]);