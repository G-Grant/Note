# Mobx 源码初探 - observable

`observable` 同时支持 `decorator` 方式和方法调用方式。

```js
// 示例
@observable name = '张三';
const temp = observable.box(20);
```

在源码中可以发现 `mobx` 为 `observable` 上绑定了方法。

```js
Object.keys(observableFactories).forEach(function(name) {
    return (observable[name] = observableFactories[name]);
});
```

`decorator` 调用方式有一个很*强大*的功能，它会对于不同类型，应用不同的转换规则。`mobx` 究竟是如何处理的，我们继续往下看。

当我们通过 `decorator` 方式使用 `observable`，实质上是调用了 `createObservable` 的返回值 `deepDecorator` 函数。`createObservable` 接收 *3* 个参数 `v`、`arg2`、`arg3`，这三个参数分别对应构造函数的原型对象、属性名、描述符。

```js
function createObservable(v, arg2, arg3) {
    // @observable someProp;
    if (typeof arguments[1] === 'string') {
        return deepDecorator.apply(null, arguments);
    }
    ...
}
```

`deepDecorator` 函数是 `createDecoratorForEnhancer` 的返回值，它把 `deepEnhancer` 作为参数传递进去。

继续深入 `createDecoratorForEnhancer` 函数，`createDecoratorForEnhancer` 函数会返回一个 `res`，传递进去的 `deepEnhancer` 会作为 `res` 的 `enhancer` 属性。`createDecoratorForEnhancer` 方法内部会通过 `createPropDecorator` 函数生成 `res`，此函数接收 2 个参数，第一个参数 `propertyInitiallyEnumerable` 设置为 `true` ( 内部写死 )，第二个参数 `propertyCreator` 为传递进来的函数，此函数返回 `decoratorFactory` 函数。

看到这里，我们先整理下，当我们编写 `@observable 属性名`，实质上就是在调用 `decoratorFactory` 函数。函数内部定义 `decorator` 函数，接下来进行判断当前的调用方式，如果是 `@decorator` 方式调用，则直接执行 `decorator` 函数。否则返回 `decorator` 函数。

当通过 `@decorator` 方式调用时，首先判断构造函数原型对象上是否存在 `__mobxDecorators` 属性，如果不存在，则定义此属性，并通过 `addHiddenProp` 方法设置其描述符。

```js
Object.defineProperty(object, propName, {
    enumerable: false,
    writable: true,
    configurable: true,
    value: value
});
```

当构造函数原型对象上存在 `__mobxDecorators` 属性，做以下操作。

```js
target.__mobxDecorators[prop] = {
    prop: prop, // 属性名
    propertyCreator: propertyCreator, // 传递进来的函数
    descriptor: descriptor, // 描述符
    decoratorTarget: target, // 构造函数原型对象
    decoratorArguments: decoratorArguments // []
};
```

最后返回调用 `createPropertyInitializerDescriptor` 函数的结果 -- 描述符，`createPropertyInitializerDescriptor` 函数内部会对属性进行分类，主要分为可枚举与不可枚举。返回的描述符有两个**注意点**，**其一**是描述符如果生成过一次后，下次如果是相同属性，会直接去缓存对象中取，**其二**是描述符中有 `get` 和 `set` 方法，这两个方法内部都会首先调用 `initializeInstance` 方法。`initializeInstance` 方法中会调用 `__mobxDecorators` 上对应的 `propertyCreator` 方法，`__mobxDecorators` 可能有多个属性，这一块会去调用对应属性的方法。

`propertyCreator` 哪来的？是我们在调用 `createPropDecorator` 函数传递进去的第二个参数，`propertyCreator` 内部首先会判断描述符中是否存在 `get`，如果存在，则报错。不存在，则判断描述符是否有 `initializer` 方法。这个方法一般都是代表这个属性有初始值，如果没有，则取描述符的 `value`。如果描述符都不存在，则为 `undefined`。

```js
var initialValue = descriptor
    ? descriptor.initializer
        ? descriptor.initializer.call(target)
        : descriptor.value
    : undefined;
```

初始值获取之后，调用 `defineObservableProperty` 方法，传入 `target` 构造函数原型对象、`propertyName` 属性名、`initialValue` 初始值和 `enhancer` ( `deepEnhancer` )。

```js
function defineObservableProperty(target, propName, newValue, enhancer) {
    var adm = asObservableObject(target);
}
```

`defineObservableProperty` 首先会判断原型对象是否可扩展，如果不可以，则报错。用构造函数的名字 `@` 自增长 `ID` 结合赋给 `name`，随后调用 `ObservableObjectAdministration` 生成原型对象上 `$mobx` 属性值，`name` 作为 `$mobx` 中一个属性存在。判断原型对象是否可配置和可写，如果不可以则报错。

通过调用 `new ObservableValue()` 来生成 `$mobx` 中 `values` 对应的属性值，并传入 `value`，`enhancer`，`name` 和 `notifySpy` 默认值为 `false`。通过继承 `Atom` 为 `_this` 增加属性，并调用 `enhancer` 方法来生成 `value`。

```js
// adm 就是对应的 $mobx
var observable = (adm.values[propName] = new ObservableValue(
    newValue,
    enhancer,
    adm.name + "." + propName,
    false
));

function ObservableValue(value, enhancer, name, notifySpy, equals) {
    if (name === void 0) {
        name = "ObservableValue@" + getNextId();
    }
    if (notifySpy === void 0) {
        notifySpy = true;
    }
    if (equals === void 0) {
        equals = comparer.default; // 判断两个数值是否都为 NaN 和是否相等
    }
    var _this = _super.call(this, name) || this; // _super 为 Atom
    ...
    _this.value = enhancer(value, undefined, name); // enhancer 为 deepEnhancer
    ...
}
```

`deepEnhancer` 会对原型对象进行判断，如果是 `observable`，直接返回原型对象；如果是数组，返回 `observable.array` 调用后结果；如果是对象，返回 `observable.object` 调用后结果；如果是 `Map`，返回 `observable.map` 调用后结果；如果是 `Set`，返回 `observable.set` 调用后结果。

```js
var deepDecorator = createDecoratorForEnhancer(deepEnhancer);
function deepEnhancer(v, _, name) {
    if (isObservable(v)) return v;
    if (Array.isArray(v)) return observable.array(v, { name: name });
    if (isPlainObject(v)) return observable.object(v, undefined, { name: name });
    if (isES6Map(v)) return observable.map(v, { name: name });
    if (isES6Set(v)) return observable.set(v, { name: name });
    return v;
}
```

最终把 `_this` 返回出去，并在原型对象上 `values` 上增加对应的描述符，此描述符是通过 `generateObservablePropConfig` 生成的。`observable` 属性的读取都是通过这里的 `read` 和 `write` 操作的。

```js
{
    configurable: true,
    enumerable: true,
    get: function() {
        return this.$mobx.read(this, propName);
    },
    set: function(v) {
        this.$mobx.write(this, propName, v);
    }
}
```

-----------------

说实话，`mobx` 的源码真的难读，这篇文章后续还会继续修正。`observable` 通过 `decorator` 方式调用的逻辑基本上写完，但是里面仍有一些瑕疵，但不影响阅读。

**瑕疵**：`target` 究竟是啥，笔者的理解是构造函数的原型对象，但是打印后发现，与我理解的有出入。

-----------------

此篇文章仅供参考，如果您有更好的方式或者建议，欢迎留言。
