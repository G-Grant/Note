# Mobx 源码初探 - observable（二）

> [上一节](./20190811.md)讲到，`observable` 不仅支持 `decorator` 方式，还支持方法调用。

`observable` 共支持 `box`、`shallowBox`、`array`、`shallowArray`、`map`、`shallowMap`、`set`、`object`、`shallowObject`、`ref`、`shallow`、`deep`、`struct` 13 种方法。

- `box`、`shallowBox`、`array`、`shallowArray`、`map`、`shallowMap`、`set` 会判断参数是否大于 **2**，如果大于则报错。`shallowBox`、`shallowArray`、`shallowMap` 已经废弃。

- `shallowObject` 会判断第二个参数是否为 `string`，如果不是则报错。此方法以及废弃，代替方法为 `object`。

- `ref`、`shallow`、`deep`、`struct` 四个方法很有意思，其中 `deep` 对应的是 `deepDecorator` 方法，当我们调用 `@observable.deep` 就相当于调用 `@observable`，剩下的三个则对应不同的 `enhancer`。

    > 注：如果直接调用这个四个方法，会返回描述符，所以我们的调用方式仍然为 `@observable.deep`。

## 四个 enhancer

`mobx` 共有四个 `enhancer`，为 `deepEnhancer`、`shallowEnhancer`、`referenceEnhancer` 和 `refStructEnhancer`。

### deepEnhancer

`deepEnhancer` 在上一节已经讲过，其是任何 `observable` 都使用的默认的调节器。它将任何(尚未成为 `observable` )数组，映射或纯对象克隆并转换为 `observable` 对象，并将其赋值给给定属性。

### shallowEnhancer

只能与集合组合使用。将任何分配的集合转换为 observable，但该集合的值将按原样处理。

### referenceEnhancer

不转换为 `observable`。

```js
function referenceEnhancer(newValue) {
    // never turn into an observable
    return newValue;
}
```

### refStructEnhancer

就像 `referenceEnhancer`, 但会忽略结构上等于当前值的新值。

```js
function refStructEnhancer(v, oldValue, name) {
    if (true && isObservable(v))
        throw "observable.struct should not be used with observable values";
    if (deepEqual(v, oldValue)) return oldValue;
    return v;
}
```

## observable.box

### 用法

```js
name = observable.box(2)
```

### 源码解读

```js
// 首先判断是否以 `decorator` 方式调用，如果是则报错
if (arguments.length > 2) incorrectlyUsedAsDecorator("box");
// 生成第二个参数，并校验传入的第二个参数格式，默认为{ deep: true, name: undefined, defaultDecorator: undefined }
var o = asCreateObservableOptions(options);
return new ObservableValue(value, getEnhancerFromOptions(o), o.name, true, o.equals);
```

## observable.array

## observable.map

## observable.set

## observable.object
